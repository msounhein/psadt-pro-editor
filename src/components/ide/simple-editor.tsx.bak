"use client";

import React, { useEffect, useRef, useState, useCallback, useMemo, useReducer } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from '@/components/ui/button';
import { Save, Play, FolderTree, Folder, File, FileCode, FileText, RefreshCw, AlertTriangle, Search, X, Sun, Moon, Settings, ChevronDown, ChevronRight, MoreVertical } from 'lucide-react';
import { cn } from '@/lib/utils';
import * as monaco from 'monaco-editor';
import { Input } from '@/components/ui/input';
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel
} from '@/components/ui/dropdown-menu';

// Define a type for Monaco editor
type MonacoEditor = {
  getModel: () => any;
  getValue: () => string;
  onDidChangeModelContent: (listener: any) => { dispose: () => void };
};

type EditorModel = monaco.editor.ITextModel;

type Monaco = typeof monaco;

interface SimpleEditorProps {
  templateId?: string | null;
  initialValue?: string;
  height?: string;
  language?: string;
  theme?: string;
  onSave?: ((value: string) => void) | undefined;
  onRun?: ((content: string) => void) | null;
  onChange?: (value: string) => void;
  readOnly?: boolean;
}

export default function SimpleEditor({
  templateId,
  initialValue = '# Enter PowerShell code here\n\n',
  height = '100%',
  language = 'powershell',
  theme = 'vs-dark',
  onSave,
  onRun,
  onChange,
  readOnly = false
}: SimpleEditorProps) {
  const editorRef = useRef<MonacoEditor | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [loading, setLoading] = useState(true);
  const [content, setContent] = useState(initialValue);
  const [fileTree, setFileTree] = useState<string[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [isEditorReady, setIsEditorReady] = useState(false);
  const [editorValue, setEditorValue] = useState(initialValue);
  const monacoRef = useRef<Monaco | null>(null);
  const [selectedFile, setSelectedFile] = useState<string | null>(null);
  const [fileContents, setFileContents] = useState<{[key: string]: string}>({});
  const [fileStatus, setFileStatus] = useState<string>('');
  const [isFileLoading, setIsFileLoading] = useState<boolean>(false);
  const [fileError, setFileError] = useState<string | null>(null);
  const [isBinaryFile, setIsBinaryFile] = useState<boolean>(false);
  const [isSaving, setIsSaving] = useState<boolean>(false);
  const [saveSuccess, setSaveSuccess] = useState<boolean | null>(null);
  const [saveMessage, setSaveMessage] = useState<string>('');
  const [isDirty, setIsDirty] = useState<boolean>(false);
  const [editorModels, setEditorModels] = useState<Record<string, EditorModel | null>>({});
  const [refreshCounter, setRefreshCounter] = useReducer(x => x + 1, 0);
  const [isEditorFullyReady, setIsEditorFullyReady] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [isSearching, setIsSearching] = useState<boolean>(false);
  const [searchResults, setSearchResults] = useState<string[]>([]);
  const [showSearch, setShowSearch] = useState<boolean>(false);
  const [openFiles, setOpenFiles] = useState<string[]>([]);
  const [activeTab, setActiveTab] = useState<string | null>(null);
  const [editorTheme, setEditorTheme] = useState<string>(theme);
  const [expandedDirs, setExpandedDirs] = useState<Set<string>>(new Set());
  const [dirContents, setDirContents] = useState<Record<string, { name: string, path: string, type: string }[]>>({});
  const [directoryContents, setDirectoryContents] = useState<Record<string, {name: string, path: string, type: 'file' | 'directory'}[]>>({});
  const [showNewFileDialog, setShowNewFileDialog] = useState<boolean>(false);
  const [showNewFolderDialog, setShowNewFolderDialog] = useState<boolean>(false);
  const [newItemName, setNewItemName] = useState<string>('');
  const [currentDirectory, setCurrentDirectory] = useState<string>('');
  const [contextMenuPos, setContextMenuPos] = useState<{x: number, y: number} | null>(null);
  const [contextMenuTarget, setContextMenuTarget] = useState<{path: string, type: 'file' | 'directory'} | null>(null);
  const [showRenameDialog, setShowRenameDialog] = useState<boolean>(false);
  const [renameTarget, setRenameTarget] = useState<{path: string, type: 'file' | 'directory'} | null>(null);
  const [renameValue, setRenameValue] = useState<string>('');
  const [showKeyboardShortcuts, setShowKeyboardShortcuts] = useState<boolean>(false);
  const [draggedItem, setDraggedItem] = useState<{path: string, type: 'file' | 'directory'} | null>(null);
  const [dropTarget, setDropTarget] = useState<string | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [deleteTarget, setDeleteTarget] = useState<string | null>(null);
  
  // Available themes
  const themes = useMemo(() => [
    { name: 'Dark', value: 'vs-dark' },
    { name: 'Light', value: 'vs' },
    { name: 'High Contrast', value: 'hc-black' }
  ], []);

  // Adapt file paths for Windows style display
  const formatFilePath = (path: string) => {
    // Replace forward slashes with backslashes for Windows style display
    return path.replace(/\//g, '\\');
  };
  
  // Display file name only from path
  const getFileName = (path: string) => {
    return path.split(/[\\/]/).pop() || path;
  };
  
  // Determine language based on file extension
  const determineLanguage = (filePath: string): string => {
    const fileExtension = filePath.split('.').pop()?.toLowerCase();
    
    if (fileExtension === 'ps1' || fileExtension === 'psm1' || fileExtension === 'psd1') {
      return 'powershell';
    } else if (fileExtension === 'json') {
      return 'json';
    } else if (fileExtension === 'xml') {
      return 'xml';
    } else if (fileExtension === 'md' || fileExtension === 'markdown') {
      return 'markdown';
    } else if (fileExtension === 'html') {
      return 'html';
    } else if (fileExtension === 'css') {
      return 'css';
    } else if (fileExtension === 'js') {
      return 'javascript';
    } else if (fileExtension === 'ts') {
      return 'typescript';
    } else if (fileExtension === 'yaml' || fileExtension === 'yml') {
      return 'yaml';
    }
    
    // Default to plain text for unknown extensions
    return 'plaintext';
  };
  
  // Group files by directory
  const organizedFileTree = useMemo(() => {
    // Skip if no files
    if (fileTree.length === 0) {
      console.log("No files in the file tree state");
      return null;
    }
    
    console.log("Organizing file tree with", fileTree.length, "files");
    
    // Group files by directory
    const tree: Record<string, string[]> = {};
    const rootFiles: string[] = [];
    
    fileTree.forEach(file => {
      // Normalize paths for consistent processing
      const normalizedPath = file.replace(/\\/g, '/');
      const parts = normalizedPath.split('/');
      
      if (parts.length === 1) {
        // File is in the root
        rootFiles.push(file);
      } else {
        // File is in a subdirectory
        const dirPath = parts.slice(0, -1).join('/');
        if (!tree[dirPath]) {
          tree[dirPath] = [];
        }
        tree[dirPath].push(file);
      }
    });
    
    // Sort directories and files
    const sortedDirs = Object.keys(tree).sort();
    const sortedRootFiles = rootFiles.sort();
    
    console.log("Root files:", sortedRootFiles, "Directories:", sortedDirs);
    
    return { dirs: sortedDirs, tree, rootFiles: sortedRootFiles };
  }, [fileTree]);

  // Toggle folder expansion
  const toggleFolder = (folder: string, e?: React.MouseEvent) => {
    if (e) {
      e.stopPropagation();
      e.preventDefault();
    }
    
    console.log(`Toggling folder: ${folder}`);
    
    // Always fetch directory contents regardless of expansion state
    fetchDirectoryContents(folder);
    
    setExpandedDirs(prev => {
      const newSet = new Set(prev);
      
      if (newSet.has(folder)) {
        console.log(`Collapsing folder: ${folder}`);
        newSet.delete(folder);
      } else {
        console.log(`Expanding folder: ${folder}`);
        newSet.add(folder);
      }
      
      return newSet;
    });
  };

  // Get folder icon with better indication of content
  const getFolderIcon = (folder: string, isExpanded: boolean, hasContent: boolean = false) => {
    if (isExpanded) {
      return <Folder className="h-4 w-4 mr-2 text-blue-400 flex-shrink-0" />;
    } else if (hasContent) {
      return <FolderTree className="h-4 w-4 mr-2 text-yellow-400 flex-shrink-0" />;
    } else {
      return <Folder className="h-4 w-4 mr-2 text-yellow-400 flex-shrink-0" />;
    }
  };

  useEffect(() => {
    console.log("File tree state updated:", fileTree);
    if (fileTree.length > 0) {
      console.log("File tree has files:", fileTree);
    }
  }, [fileTree]);

  useEffect(() => {
    // Dynamically load Monaco Editor
    const loadMonaco = async () => {
      try {
        setLoading(true);
        console.log("Loading Monaco editor...");
        
        // Import monaco editor dynamically
        const monaco = await import('monaco-editor');
        monacoRef.current = monaco;
        console.log("Monaco editor modules imported");
        
        // Configure PowerShell language support if needed
        monaco.languages.register({ id: 'powershell' });
        
        // Basic syntax highlighting for PowerShell
        monaco.languages.setMonarchTokensProvider('powershell', {
          tokenizer: {
            root: [
              [/\$[\w]+/, 'variable'],
              [/#.*$/, 'comment'],
              [/\[.*\]/, 'type'],
              [/\b(function|param|if|else|foreach|for|while|switch|return|try|catch|finally)\b/, 'keyword'],
              [/\b(Get|Set|New|Remove|Add|Install|Uninstall|Import|Export|Start|Stop|Write|Read)-[\w]+\b/, 'function'],
              [/".*?"/, 'string'],
              [/'.*?'/, 'string'],
            ]
          }
        });
        
        if (!containerRef.current) {
          console.warn("Container ref is not available");
          setLoading(false);
          return;
        }
        
        // Clean up any existing editor instance
        if (editorRef.current) {
          console.log("Disposing previous editor instance");
          (editorRef.current as any).dispose();
          editorRef.current = null;
        }
        
        // Dispose of any existing models
        if (monacoRef.current) {
          console.log("Disposing existing models");
          monaco.editor.getModels().forEach(model => {
            model.dispose();
          });
        }
        
        console.log("Creating new editor instance");
        // Create editor with initial content
        const editor = monaco.editor.create(containerRef.current, {
          value: initialValue,
          language: language,
          theme: editorTheme,
          automaticLayout: true,
          readOnly: readOnly,
          minimap: { enabled: true },
          scrollBeyondLastLine: false,
          lineNumbers: 'on',
          glyphMargin: true,
          folding: true,
          fontSize: 14,
          fontFamily: 'Consolas, "Liberation Mono", Menlo, Courier, monospace',
          renderLineHighlight: 'all',
          cursorBlinking: 'smooth',
          cursorSmoothCaretAnimation: 'on',
          smoothScrolling: true,
          wordWrap: 'on'
        });
        
        editorRef.current = editor as unknown as MonacoEditor;
        console.log("Editor created and references set");
        
        // Set up change listener
        const changeListener = editor.onDidChangeModelContent(() => {
          if (editorRef.current) {
            const newValue = editorRef.current.getValue();
            console.log("Editor content changed, updating state");
            setContent(newValue);
            if (selectedFile) {
              setIsDirty(true);
            }
            if (onChange) onChange(newValue);
          }
        });
        
        // If we have a templateId, try to load template-specific data
        if (templateId) {
          console.log(`Loading template files for template ID: ${templateId}`);
          await fetchTemplateFiles(templateId);
          console.log("Template files loaded");
          
          // Auto-expand important folders after files are loaded
          setTimeout(() => {
            // This timeout ensures the file tree is populated
            if (organizedFileTree?.dirs) {
              const foldersToExpand = organizedFileTree.dirs.filter(dir => {
                const dirName = dir.split('/').pop() || '';
                return dirName.includes('PSAppDeployToolkit') || 
                       dirName === 'Files' || 
                       dirName === 'SupportFiles';
              });
              
              if (foldersToExpand.length > 0) {
                const newExpandedDirs = new Set<string>();
                foldersToExpand.forEach(dir => {
                  newExpandedDirs.add(dir);
                  fetchDirectoryContents(dir);
                });
                setExpandedDirs(newExpandedDirs);
              }
            }
          }, 500);
        }
        
        setLoading(false);
        setIsEditorReady(true);
        
        // If we already have a selected file, load it immediately
        if (selectedFile && fileContents[selectedFile]) {
          console.log(`Loading content for ${selectedFile} on editor init`);
          setTimeout(() => {
            try {
              editor.setValue(fileContents[selectedFile]);
              // Determine language from file extension
              const fileExtension = selectedFile.split('.').pop()?.toLowerCase();
              let fileLanguage = language;
              
              if (fileExtension === 'ps1' || fileExtension === 'psm1' || fileExtension === 'psd1') {
                fileLanguage = 'powershell';
              } else if (fileExtension === 'json') {
                fileLanguage = 'json';
              } else if (fileExtension === 'xml') {
                fileLanguage = 'xml';
              } else if (fileExtension === 'txt' || fileExtension === 'log') {
                fileLanguage = 'plaintext';
              } else if (fileExtension === 'md') {
                fileLanguage = 'markdown';
              }
              
              // Set model language
              const model = editor.getModel();
              if (model) {
                monaco.editor.setModelLanguage(model, fileLanguage);
              }
            } catch (err) {
              console.error("Error setting initial file content:", err);
            }
          }, 100);
        }
        
        console.log("Monaco editor initialization complete");
        
        // Mark editor as fully ready after a short delay
        setTimeout(() => {
          setIsEditorFullyReady(true);
          console.log("Editor fully ready for content");
        }, 300);
        
        return () => {
          console.log("Cleaning up Monaco editor");
          changeListener.dispose();
          editor.dispose();
          
          // Dispose all models
          monaco.editor.getModels().forEach(model => {
            model.dispose();
          });
        };
      } catch (err) {
        console.error('Failed to load Monaco editor:', err);
        setError('Failed to load code editor. Please try refreshing the page.');
        setLoading(false);
      }
    };
    
    loadMonaco();
    
    // Cleanup function to dispose of editor and models when component unmounts
    return () => {
      if (editorRef.current && typeof (editorRef.current as any).dispose === 'function') {
        console.log("Disposing editor on component unmount");
        (editorRef.current as any).dispose();
      }
      
      // Dispose all Monaco models to prevent memory leaks
      if (monacoRef.current) {
        console.log("Disposing all models on component unmount");
        monacoRef.current.editor.getModels().forEach(model => {
          model.dispose();
        });
      }
      
      // Clear cached models from state
      setEditorModels({});
    };
  }, [templateId, refreshCounter]);
  
  const fetchTemplateFiles = async (id: string) => {
    if (!id) return;
    
    setIsFileLoading(true);
    setFileError(null);
    
    try {
      console.log(`Fetching files for template ID: ${id}`);
      const response = await fetch(`/api/templates/${id}/files`, {
        method: 'GET',
        headers: {
          'Cache-Control': 'no-cache'
        }
      });
      
      console.log(`Response status: ${response.status} ${response.statusText}`);
      
      // Handle different response status codes
      if (response.status === 404) {
        console.error(`Template not found with ID: ${id}`);
        setFileTree([]);
        setIsFileLoading(false);
        setFileError("Template not found");
        return;
      }
      
      // Try to parse response even if it's not OK
      let data;
      try {
        data = await response.json();
        console.log(`Template files response:`, data);
      } catch (parseError) {
        console.error("Error parsing response:", parseError);
        if (!response.ok) {
          throw new Error(`Failed to fetch files: ${response.status} ${response.statusText}`);
        }
        data = { files: [] };
      }
      
      if (data.files && Array.isArray(data.files)) {
        console.log(`Found ${data.files.length} files`);
        setFileTree(data.files.map((file: any) => typeof file === 'string' ? file : file.path));
      } else if (data.error) {
        console.error(`Server reported error: ${data.error}`, data.message || '');
        setFileError(data.error);
        setFileTree([]);
      } else {
        console.warn(`Unexpected file data format:`, data);
        setFileTree([]);
      }
      
      setIsFileLoading(false);
    } catch (error) {
      console.error("Error fetching template files:", error);
      setFileError("Failed to load files. Please check console for details.");
      setFileTree([]);
      setIsFileLoading(false);
    }
  };
  
  // Create a concrete function to handle the save callback
  const saveCallback = (value: string) => {
    if (onSave) {
      onSave(value);
    }
  };

  // Add a change tracking function
  const handleEditorChange = (value: string | undefined) => {
    const newValue = value || '';
    
    // Only mark as dirty if there's a selected file and content has changed
    if (selectedFile && fileContents[selectedFile] !== newValue) {
      setIsDirty(true);
    } else if (!selectedFile) {
      // When no file is selected, just track changes normally
      setEditorValue(newValue);
      if (onChange) onChange(newValue);
    }
    
    // Always update content
    setContent(newValue);
    setEditorValue(newValue);
    if (onChange) onChange(newValue);
  };

  // Update the handleSave to use the concrete function
  const handleSave = useCallback(async () => {
    if (!editorRef.current) return;
    
    const currentContent = editorRef.current.getValue();
    
    // If we have a selected file, save that specific file
    if (templateId && selectedFile) {
      try {
        setIsSaving(true);
        setSaveSuccess(null);
        setSaveMessage(`Saving ${selectedFile}...`);
        
        const response = await fetch(`/api/templates/${templateId}/files/content`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            filePath: selectedFile,
            content: currentContent,
          }),
        });
        
        if (!response.ok) {
          throw new Error(`Failed to save file: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
          setSaveSuccess(true);
          setSaveMessage(`${selectedFile} saved successfully`);
          console.log(`File saved: ${selectedFile}`);
          
          // Update cache with the new content
          setFileContents(prev => ({
            ...prev,
            [selectedFile]: currentContent,
          }));
          
          // Reset dirty state
          setIsDirty(false);
          
          // Call onSave if provided
          if (typeof onSave === 'function') {
            try {
              onSave(currentContent);
            } catch (e) {
              console.error('Error calling onSave callback:', e);
            }
          }
          
          // Reset success message after a delay
          setTimeout(() => {
            setSaveSuccess(null);
            setSaveMessage('');
          }, 3000);
        } else {
          throw new Error(data.error || 'Unknown error saving file');
        }
      } catch (err) {
        console.error('Error saving file:', err);
        setSaveSuccess(false);
        setSaveMessage(err instanceof Error ? err.message : 'Failed to save file');
        
        // Reset error message after a delay
        setTimeout(() => {
          setSaveSuccess(null);
          setSaveMessage('');
        }, 5000);
      } finally {
        setIsSaving(false);
      }
    } else {
      // No file selected, just use the default save callback
      saveCallback(currentContent);
    }
  }, [templateId, selectedFile, onSave]);
  
  const handleExecute = () => {
    // Here we could implement PowerShell execution functionality
    console.log('Execute code:', content);
    // This would typically call an API endpoint to execute the code
  };

  // Update the handleEditorDidMount function
  const handleEditorDidMount = (editor: any, monaco: Monaco) => {
    editorRef.current = editor;
    monacoRef.current = monaco;
    console.log("Editor mounted, references set");
    
    // Register a one-time callback to set fully ready after a short delay
    setTimeout(() => {
      setIsEditorFullyReady(true);
      console.log("Editor fully ready for content");
      
      // If we already have a selected file and content when the editor mounts, 
      // make sure to set it immediately
      if (selectedFile && fileContents[selectedFile]) {
        console.log(`Setting initial content for ${selectedFile} on mount`);
        // Use proper casting for the editor instance
        (editor as any).setValue(fileContents[selectedFile]);
        
        // Make sure language is set correctly
        const fileExtension = selectedFile.split('.').pop()?.toLowerCase();
        let fileLanguage = language;
        
        // Set language based on file extension
        if (fileExtension === 'ps1' || fileExtension === 'psm1' || fileExtension === 'psd1') {
          fileLanguage = 'powershell';
        } else if (fileExtension === 'json') {
          fileLanguage = 'json';
        } else if (fileExtension === 'xml') {
          fileLanguage = 'xml';
        } else if (fileExtension === 'txt' || fileExtension === 'log') {
          fileLanguage = 'plaintext';
        } else if (fileExtension === 'md') {
          fileLanguage = 'markdown';
        } else if (fileExtension === 'cs') {
          fileLanguage = 'csharp';
        } else if (fileExtension === 'js') {
          fileLanguage = 'javascript';
        } else if (fileExtension === 'html') {
          fileLanguage = 'html';
        } else if (fileExtension === 'css') {
          fileLanguage = 'css';
        }
        
        // Update model language
        try {
          const model = editor.getModel();
          if (model) {
            monaco.editor.setModelLanguage(model, fileLanguage);
            console.log(`Set model language to ${fileLanguage}`);
          }
        } catch (err) {
          console.error("Error setting model language:", err);
        }
      }
    }, 200);
    
    // Register PowerShell language if not registered
    if (!monaco.languages.getLanguages().some((lang: { id: string }) => lang.id === 'powershell')) {
      monaco.languages.register({ id: 'powershell' });
      
      // Basic syntax highlighting for PowerShell
      monaco.languages.setMonarchTokensProvider('powershell', {
        tokenizer: {
          root: [
            [/\$[\w]+/, 'variable'],
            [/#.*$/, 'comment'],
            [/\[.*\]/, 'type'],
            [/\b(function|param|if|else|foreach|for|while|switch|return|try|catch|finally)\b/, 'keyword'],
            [/\b(Get|Set|New|Remove|Add|Install|Uninstall|Import|Export|Start|Stop|Write|Read)-[\w]+\b/, 'function'],
            [/".*?"/, 'string'],
            [/'.*?'/, 'string'],
          ]
        }
      });
    }
    
    setIsEditorReady(true);
  };

  // Add a special effect to directly update content when a file is selected
  useEffect(() => {
    if (isEditorFullyReady && selectedFile && fileContents[selectedFile] && editorRef.current) {
      console.log("Direct DOM update for selected file:", selectedFile);
      
      try {
        // Get current content and file content
        const currentValue = editorRef.current.getValue();
        const fileContent = fileContents[selectedFile];
        
        // Only update if content differs
        if (currentValue !== fileContent) {
          console.log("Content differs, forcing update via direct DOM manipulation");
          (editorRef.current as any).setValue(fileContent);
          
          // Try to get model and update its language if needed
          if (monacoRef.current) {
            const fileExtension = selectedFile.split('.').pop()?.toLowerCase();
            let fileLanguage = language;
            
            // Set language based on file extension
            if (fileExtension === 'ps1' || fileExtension === 'psm1' || fileExtension === 'psd1') {
              fileLanguage = 'powershell';
            } else if (fileExtension === 'json') {
              fileLanguage = 'json';
            } else if (fileExtension === 'xml') {
              fileLanguage = 'xml';
            } else if (fileExtension === 'txt' || fileExtension === 'log') {
              fileLanguage = 'plaintext';
            } else if (fileExtension === 'md') {
              fileLanguage = 'markdown';
            } else if (fileExtension === 'cs') {
              fileLanguage = 'csharp';
            } else if (fileExtension === 'js') {
              fileLanguage = 'javascript';
            } else if (fileExtension === 'html') {
              fileLanguage = 'html';
            } else if (fileExtension === 'css') {
              fileLanguage = 'css';
            }
            
            const model = editorRef.current.getModel();
            if (model) {
              try {
                monacoRef.current.editor.setModelLanguage(model, fileLanguage);
                console.log(`Updated model language to ${fileLanguage}`);
              } catch (err) {
                console.error("Error updating model language:", err);
              }
            }
          }
          
          // Force a layout update to ensure content is displayed properly
          setTimeout(() => {
            try {
              const editor = editorRef.current as any;
              if (editor && editor.layout) {
                editor.layout();
                editor.focus();
                console.log("Layout updated and editor focused");
              }
            } catch (err) {
              console.error("Error updating layout:", err);
            }
          }, 100);
        }
      } catch (err) {
        console.error("Error in direct DOM update:", err);
      }
    }
  }, [isEditorFullyReady, selectedFile, fileContents, language]);

  // Update the useEffect to force update the editor when the content changes
  useEffect(() => {
    if (editorRef.current && isEditorReady && content) {
      const currentValue = editorRef.current.getValue();
      if (currentValue !== content) {
        console.log("Manually updating editor content from state");
        // Use proper casting for the editor reference
        (editorRef.current as any).setValue(content);
      }
    }
  }, [content, isEditorReady]);

  // Handle run button click
  const handleRun = () => {
    if (editorRef.current && typeof onRun === 'function') {
      const content = editorRef.current.getValue();
      onRun(content);
    }
  };

  // Add this function to get the appropriate icon for a file type
  const getFileIcon = (fileName: string) => {
    const extension = fileName.split('.').pop()?.toLowerCase();
    
    switch (extension) {
      case 'ps1':
      case 'psm1':
      case 'psd1':
        return <FileCode className="h-4 w-4 mr-2 text-blue-400" />;
      case 'txt':
      case 'md':
      case 'log':
        return <FileText className="h-4 w-4 mr-2 text-gray-400" />;
      default:
        return <File className="h-4 w-4 mr-2 text-[#cccccc]" />;
    }
  };

  // Add a dedicated model management function
  const getOrCreateModel = useCallback((filePath: string, content: string, language: string): EditorModel => {
    // If we already have a model for this file, return it
    if (editorModels[filePath] && !editorModels[filePath]?.isDisposed()) {
      return editorModels[filePath] as EditorModel;
    }
    
    // Otherwise create a new model
    if (monacoRef.current) {
      // Create a unique URI for the model
      const uri = monacoRef.current.Uri.parse(`file:///${filePath.replace(/\\/g, '/')}`);
      
      // Dispose existing model for this URI if it exists
      const existingModel = monacoRef.current.editor.getModel(uri);
      if (existingModel) {
        existingModel.dispose();
      }
      
      // Create a new model
      const model = monacoRef.current.editor.createModel(content, language, uri);
      
      // Cache the model
      setEditorModels(prev => ({
        ...prev,
        [filePath]: model
      }));
      
      return model;
    }
    
    throw new Error("Monaco editor not initialized");
  }, [editorModels, monacoRef]);

  // Fetch file content from API
  const fetchFileContent = async (filePath: string): Promise<string | null> => {
    if (!templateId) {
      console.error('No template ID available');
      return null;
    }

    setIsFileLoading(true);
    setFileError(null);
    
    try {
      console.log(`Fetching content for: ${filePath}`);
      const response = await fetch(`/api/templates/${templateId}/files/content?filepath=${encodeURIComponent(filePath)}`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch file: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Check if the response is for a directory instead of a file
      if (data.isDirectory) {
        console.log(`Requested file ${filePath} is actually a directory:`, data);
        // Handle as directory click - expand/collapse it
        const newExpandedDirs = new Set(expandedDirs);
        if (newExpandedDirs.has(filePath)) {
          newExpandedDirs.delete(filePath);
        } else {
          newExpandedDirs.add(filePath);
          // Update directory contents cache
          if (data.children) {
            setDirectoryContents(prev => ({
              ...prev,
              [filePath]: data.children
            }));
          }
        }
        setExpandedDirs(newExpandedDirs);
        setIsFileLoading(false);
        return null;
      }
      
      setIsFileLoading(false);
      
      if (data.content !== undefined) {
        // Cache the content
        const contentToCache = data.content || '';
        console.log(`Received content for ${filePath}:`, contentToCache.length, 'bytes');
        
        // Cache the file content
        setFileContents(prev => ({
          ...prev,
          [filePath]: contentToCache
        }));
        
        // Update the content state
        setContent(contentToCache);
        setEditorValue(contentToCache);
        
        setFileStatus(`Loaded ${filePath}`);
        setIsFileLoading(false);
        
        // Get or create a model for this file
        const fileLanguage = determineLanguage(filePath);
        const model = getOrCreateModel(filePath, contentToCache, fileLanguage);
        
        // Set the model on the editor
        if (editorRef.current && monacoRef.current) {
          editorRef.current.getModel()?.dispose();
          (editorRef.current as any).setModel(model);
        }
        
        return contentToCache;
      } else {
        console.warn('Unexpected response format or empty content:', data);
        setFileError(data.error || 'Failed to load file content');
        setIsFileLoading(false);
        forceUpdate();
        return null;
      }
    } catch (err) {
      console.error('Error fetching file content:', err);
      setFileError(err instanceof Error ? err.message : 'Unknown error loading file');
      setIsFileLoading(false);
      forceUpdate();
      return null;
    }
  };

  // Update the function signature to match the expected order
  const handleFileClick = async (e: React.MouseEvent, file: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    // First, check if this might be a directory by looking at the file tree
    const isDirectory = fileTree.some(f => {
      // For root level entries that don't have path separators
      if (!file.includes('/') && !file.includes('\\')) {
        // Check if this filename is in the organized directories list
        return organizedFileTree?.dirs.includes(file) || false;
      }
      
      // For nested paths, check if any file has this as a parent directory
      // Normalize the paths for comparison
      const normalizedFile = file.replace(/\\/g, '/');
      const normalizedF = f.replace(/\\/g, '/');
      return normalizedF.startsWith(normalizedFile + '/');
    });
    
    // Handle directory differently
    if (isDirectory) {
      console.log(`Clicked on directory: ${file}`);
      
      // Toggle expanded state
      const newExpandedDirs = new Set(expandedDirs);
      if (newExpandedDirs.has(file)) {
        newExpandedDirs.delete(file);
      } else {
        newExpandedDirs.add(file);
        fetchDirectoryContents(file);
      }
      setExpandedDirs(newExpandedDirs);
      return;
    }
    
    // Rest of the function for handling files...
    // Check if the current file has unsaved changes
    if (isDirty && selectedFile) {
      // Ask user if they want to save changes before switching files
      if (window.confirm(`Save changes to ${getFileName(selectedFile)} before opening another file?`)) {
        await handleSave();
      }
      setIsDirty(false);
    }
    
    // Set the selected file
    setSelectedFile(file);
    
    // Add file to open tabs if not already open
    if (!openFiles.includes(file)) {
      setOpenFiles(prev => [...prev, file]);
    }
    
    // Set as active tab
    setActiveTab(file);
    
    // Load file content
    await fetchFileContent(file);
  };
  
  // Function to fetch directory contents
  const fetchDirectoryContents = async (dirPath: string) => {
    if (directoryContents[dirPath]) {
      // Already have contents cached
      console.log(`Using cached contents for ${dirPath}:`, directoryContents[dirPath]);
      return;
    }
    
    try {
      console.log(`Fetching contents for directory: ${dirPath}`);
      
      // Show loading state immediately
      setDirectoryContents(prev => ({
        ...prev,
        [dirPath]: [] // Empty array indicates loading state
      }));
      
      // Ensure the path is properly encoded
      const encodedPath = encodeURIComponent(dirPath);
      const response = await fetch(`/api/templates/${templateId}/files/content?filepath=${encodedPath}`);
      
      if (!response.ok) {
        console.error(`Error fetching directory contents: ${response.statusText}`);
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      console.log(`Directory contents response for ${dirPath}:`, data);
      
      if (data.isDirectory && Array.isArray(data.children)) {
        console.log(`Received directory contents for ${dirPath}:`, data.children);
        
        // Update state with function form to ensure we're using the latest state
        setDirectoryContents(prev => ({
          ...prev,
          [dirPath]: data.children
        }));
      }
    } catch (error) {
      console.error(`Error fetching directory contents:`, error);
      // Show error state
      setDirectoryContents(prev => ({
        ...prev,
        [dirPath]: [{ 
          name: "Error loading contents", 
          path: `${dirPath}/error`, 
          type: 'file' 
        }]
      }));
    }
  };

  // Close a tab
  const handleCloseTab = (file: string, e: React.MouseEvent) => {
    e.stopPropagation();
    e.preventDefault();
    
    // Check for unsaved changes
    if (isDirty && selectedFile === file) {
      if (window.confirm(`Save changes to ${getFileName(file)} before closing?`)) {
        handleSave();
      }
      setIsDirty(false);
    }
    
    // Remove from open files
    setOpenFiles(prev => prev.filter(f => f !== file));
    
    // If this was the active tab, set a new active tab
    if (activeTab === file) {
      const newOpenFiles = openFiles.filter(f => f !== file);
      if (newOpenFiles.length > 0) {
        const newActiveTab = newOpenFiles[newOpenFiles.length - 1];
        setActiveTab(newActiveTab);
        setSelectedFile(newActiveTab);
        fetchFileContent(newActiveTab);
      } else {
        setActiveTab(null);
        setSelectedFile(null);
      }
    }
  };

  // Add keyboard shortcut for save
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl+S or Cmd+S (Mac)
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault(); // Prevent browser save dialog
        if (isEditorReady && !isSaving) {
          handleSave();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleSave, isEditorReady, isSaving]);

  // Clean up models when component unmounts
  useEffect(() => {
    return () => {
      // Dispose all editor models
      Object.values(editorModels).forEach(model => {
        if (model && typeof model.dispose === 'function') {
          model.dispose();
        }
      });
    };
  }, [editorModels]);

  // Update the forceUpdate function to also increment the refresh counter
  const forceUpdate = () => {
    console.log('Forcing component update');
    setRefreshCounter();
  };

  // Filter files based on search query
  const filteredFiles = useMemo(() => {
    if (!searchQuery.trim()) {
      return fileTree;
    }
    
    const query = searchQuery.toLowerCase();
    return fileTree.filter(file => {
      const fileName = getFileName(file).toLowerCase();
      return fileName.includes(query);
    });
  }, [fileTree, searchQuery]);
  
  // Handle search toggle
  const toggleSearch = () => {
    setShowSearch(prev => !prev);
    if (showSearch) {
      // Clear search when closing
      setSearchQuery('');
    }
  };
  
  // Clear search
  const clearSearch = () => {
    setSearchQuery('');
    setSearchResults([]);
  };
  
  // Search in file content
  const searchInFiles = async () => {
    if (!templateId || !searchQuery.trim()) return;
    
    try {
      setIsSearching(true);
      
      // Make API call to search in file content
      const response = await fetch(`/api/templates/${templateId}/files/search?query=${encodeURIComponent(searchQuery)}`);
      
      if (!response.ok) {
        throw new Error("Failed to search in files");
      }
      
      const data = await response.json();
      setSearchResults(data.results || []);
    } catch (error) {
      console.error("Error searching in files:", error);
    } finally {
      setIsSearching(false);
    }
  };
  
  // Handle keydown events for search
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Ctrl+F or Cmd+F to toggle search
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        toggleSearch();
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  // Change editor theme
  const handleThemeChange = (newTheme: string) => {
    setEditorTheme(newTheme);
    if (monacoRef.current) {
      monacoRef.current.editor.setTheme(newTheme);
    }
  };

  // In the loadMonaco function, use the editorTheme state instead of the theme prop
  useEffect(() => {
    if (monacoRef.current && isEditorReady) {
      monacoRef.current.editor.setTheme(editorTheme);
    }
  }, [editorTheme, isEditorReady]);

  // Create a new file
  const handleCreateFile = async (directoryPath: string = '') => {
    setCurrentDirectory(directoryPath);
    setNewItemName('');
    setShowNewFileDialog(true);
  };

  // Create a new folder
  const handleCreateFolder = async (directoryPath: string = '') => {
    setCurrentDirectory(directoryPath);
    setNewItemName('');
    setShowNewFolderDialog(true);
  };

  // Submit new file creation
  const submitNewFile = async () => {
    if (!newItemName || !templateId) return;
    
    const filePath = currentDirectory 
      ? `${currentDirectory}/${newItemName}` 
      : newItemName;
    
    try {
      setIsFileLoading(true);
      
      const response = await fetch(`/api/templates/${templateId}/files/content`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          path: filePath,
          content: ''
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to create file: ${response.status} ${response.statusText}`);
      }
      
      // Refresh the file tree
      await fetchTemplateFiles(templateId);
      
      // If we created in a specific directory, refresh that directory's contents
      if (currentDirectory) {
        await fetchDirectoryContents(currentDirectory);
      }
      
      // Open the new file
      await handleFileClick(new MouseEvent('click') as unknown as React.MouseEvent, filePath);
      
      setShowNewFileDialog(false);
    } catch (error) {
      console.error('Error creating file:', error);
      alert(`Error creating file: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsFileLoading(false);
    }
  };

  // Submit new folder creation
  const submitNewFolder = async () => {
    if (!newItemName || !templateId) return;
    
    const folderPath = currentDirectory 
      ? `${currentDirectory}/${newItemName}` 
      : newItemName;
    
    try {
      setIsFileLoading(true);
      
      const response = await fetch(`/api/templates/${templateId}/files/directory`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          path: folderPath
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to create folder: ${response.status} ${response.statusText}`);
      }
      
      // Refresh the file tree
      await fetchTemplateFiles(templateId);
      
      // If we created in a specific directory, refresh that directory's contents
      if (currentDirectory) {
        await fetchDirectoryContents(currentDirectory);
      }
      
      // Expand the parent directory if it exists
      if (currentDirectory) {
        setExpandedDirs(prev => new Set([...prev, currentDirectory]));
      }
      
      setShowNewFolderDialog(false);
    } catch (error) {
      console.error('Error creating folder:', error);
      alert(`Error creating folder: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsFileLoading(false);
    }
  };

  // Show context menu for file/folder
  const handleContextMenu = (e: React.MouseEvent, path: string, type: 'file' | 'directory') => {
    e.preventDefault();
    e.stopPropagation();
    
    setContextMenuPos({ x: e.clientX, y: e.clientY });
    setContextMenuTarget({ path, type });
  };

  // Close context menu
  const closeContextMenu = () => {
    setContextMenuPos(null);
    setContextMenuTarget(null);
  };

  // Delete file or folder
  const handleDelete = async (path: string, type: 'file' | 'directory') => {
    if (!templateId || !path) return;
    
    const confirmMessage = type === 'directory'
      ? `Are you sure you want to delete the folder "${path}" and all its contents?`
      : `Are you sure you want to delete the file "${path}"?`;
    
    if (!window.confirm(confirmMessage)) return;
    
    try {
      setIsFileLoading(true);
      
      const endpoint = type === 'directory'
        ? `/api/templates/${templateId}/files/directory?path=${encodeURIComponent(path)}`
        : `/api/templates/${templateId}/files/content?filepath=${encodeURIComponent(path)}`;
      
      const response = await fetch(endpoint, {
        method: 'DELETE'
      });
      
      if (!response.ok) {
        throw new Error(`Failed to delete ${type}: ${response.status} ${response.statusText}`);
      }
      
      // If this was an open file, close it
      if (openFiles.includes(path)) {
        handleCloseTab(path, new MouseEvent('click') as unknown as React.MouseEvent);
      }
      
      // Refresh the file tree
      await fetchTemplateFiles(templateId);
      
      // Find parent directory of deleted item
      const parentDir = path.split(/[/\\]/).slice(0, -1).join('/');
      if (parentDir && directoryContents[parentDir]) {
        await fetchDirectoryContents(parentDir);
      }
    } catch (error) {
      console.error(`Error deleting ${type}:`, error);
      alert(`Error deleting ${type}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsFileLoading(false);
      closeContextMenu();
    }
  };

  // Handle rename
  const handleRename = (path: string, type: 'file' | 'directory') => {
    const fileName = path.split('/').pop() || '';
    setRenameTarget({ path, type });
    setRenameValue(fileName);
    setShowRenameDialog(true);
    closeContextMenu();
  };

  // Submit rename
  const submitRename = async () => {
    if (!renameTarget || !templateId || !renameValue.trim()) return;
    
    try {
      setIsFileLoading(true);
      
      const { path: oldPath, type } = renameTarget;
      const dirPath = oldPath.split('/').slice(0, -1).join('/');
      const newPath = dirPath ? `${dirPath}/${renameValue}` : renameValue;
      
      // Don't do anything if the name hasn't changed
      if (oldPath === newPath) {
        setShowRenameDialog(false);
        return;
      }
      
      const endpoint = type === 'directory'
        ? `/api/templates/${templateId}/files/directory`
        : `/api/templates/${templateId}/files/content`;
      
      const method = type === 'directory' ? 'PUT' : 'PATCH';
      
      const body = type === 'directory'
        ? { oldPath, newPath }
        : { oldPath, newPath };
      
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(body),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to rename ${type}: ${response.status} ${response.statusText}`);
      }
      
      // If this was an open file, update the open files list
      if (type === 'file' && openFiles.includes(oldPath)) {
        setOpenFiles(prev => prev.map(f => f === oldPath ? newPath : f));
        if (activeTab === oldPath) {
          setActiveTab(newPath);
        }
        if (selectedFile === oldPath) {
          setSelectedFile(newPath);
          fetchFileContent(newPath);
        }
      }
      
      // Refresh the file tree
      await fetchTemplateFiles(templateId);
      
      // If the parent directory is expanded, refresh its contents
      if (dirPath && expandedDirs.has(dirPath)) {
        await fetchDirectoryContents(dirPath);
      }
      
      setShowRenameDialog(false);
    } catch (error) {
      console.error(`Error renaming ${renameTarget.type}:`, error);
      alert(`Error renaming ${renameTarget.type}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsFileLoading(false);
    }
  };

  // Add keyboard shortcuts for file operations
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Only handle when editor is ready
      if (!isEditorReady) return;
      
      // New file: Ctrl+Alt+N
      if (e.altKey && e.ctrlKey && e.key === 'n') {
        e.preventDefault();
        handleCreateFile(currentDirectory);
        return;
      }
      
      // New folder: Ctrl+Alt+F
      if (e.altKey && e.ctrlKey && e.key === 'f') {
        e.preventDefault();
        handleCreateFolder(currentDirectory);
        return;
      }
      
      // Delete: Delete key on selected file in file tree
      if (e.key === 'Delete' && contextMenuTarget) {
        e.preventDefault();
        handleDelete(contextMenuTarget.path, contextMenuTarget.type);
        return;
      }
      
      // Rename: F2 on selected file in file tree
      if (e.key === 'F2' && contextMenuTarget) {
        e.preventDefault();
        handleRename(contextMenuTarget.path, contextMenuTarget.type);
        return;
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isEditorReady, contextMenuTarget, currentDirectory]);
  
  // Update current directory when selecting files
  useEffect(() => {
    if (selectedFile) {
      const dirPath = selectedFile.split('/').slice(0, -1).join('/');
      setCurrentDirectory(dirPath);
    }
  }, [selectedFile]);

  // Handle folder click more explicitly
  const handleFolderClick = (e: React.MouseEvent, folderPath: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Toggle folder expansion
    toggleFolder(folderPath);
    
    // Set as current directory
    setCurrentDirectory(folderPath);
    
    // Don't set it as selected file
    // Instead, just mark it as the current working directory
  };

  // Handle drag start
  const handleDragStart = (e: React.DragEvent, path: string, type: 'file' | 'directory') => {
    e.stopPropagation();
    // Set data for drag operation
    e.dataTransfer.setData('text/plain', path);
    e.dataTransfer.effectAllowed = 'move';
    setDraggedItem({ path, type });
  };

  // Handle drag over
  const handleDragOver = (e: React.DragEvent, targetPath: string) => {
    e.preventDefault();
    e.stopPropagation();
    // Only allow dropping in directories
    if (draggedItem && draggedItem.path !== targetPath) {
      e.dataTransfer.dropEffect = 'move';
      setDropTarget(targetPath);
    }
  };

  // Handle drag leave
  const handleDragLeave = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
  };

  // Handle drop
  const handleDrop = async (e: React.DragEvent, targetPath: string) => {
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
    
    if (!draggedItem || !templateId) return;
    
    // Don't drop on itself
    if (draggedItem.path === targetPath) return;
    
    // Make sure we're dropping into a directory
    const targetStats = await getPathStats(targetPath);
    if (!targetStats || targetStats.type !== 'directory') return;
    
    // Get the file/dir name from the path
    const sourceName = draggedItem.path.split('/').pop() || '';
    const newPath = `${targetPath}/${sourceName}`;
    
    try {
      setIsFileLoading(true);
      
      const endpoint = draggedItem.type === 'directory'
        ? `/api/templates/${templateId}/files/directory`
        : `/api/templates/${templateId}/files/content`;
      
      const method = 'PUT';
      
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          oldPath: draggedItem.path,
          newPath
        }),
      });
      
      if (!response.ok) {
        throw new Error(`Failed to move ${draggedItem.type}: ${response.status} ${response.statusText}`);
      }
      
      // If this was an open file, update the open files list
      if (draggedItem.type === 'file' && openFiles.includes(draggedItem.path)) {
        setOpenFiles(prev => prev.map(f => f === draggedItem.path ? newPath : f));
        if (activeTab === draggedItem.path) {
          setActiveTab(newPath);
        }
        if (selectedFile === draggedItem.path) {
          setSelectedFile(newPath);
          fetchFileContent(newPath);
        }
      }
      
      // Refresh the file tree and relevant directories
      await fetchTemplateFiles(templateId);
      
      // Refresh source and target directories
      const sourceDir = draggedItem.path.split('/').slice(0, -1).join('/');
      if (sourceDir && directoryContents[sourceDir]) {
        await fetchDirectoryContents(sourceDir);
      }
      
      if (targetPath && expandedDirs.has(targetPath)) {
        await fetchDirectoryContents(targetPath);
      }
      
      // Expand target directory if it's not already expanded
      if (!expandedDirs.has(targetPath)) {
        setExpandedDirs(prev => new Set([...prev, targetPath]));
      }
      
    } catch (error) {
      console.error(`Error moving ${draggedItem.type}:`, error);
      alert(`Error moving ${draggedItem.type}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsFileLoading(false);
      setDraggedItem(null);
    }
  };

  // Helper to get file/directory stats
  const getPathStats = async (path: string): Promise<{type: 'file' | 'directory'} | null> => {
    if (!templateId) return null;
    
    try {
      const response = await fetch(`/api/templates/${templateId}/files/content?filepath=${encodeURIComponent(path)}`);
      
      if (!response.ok) return null;
      
      const data = await response.json();
      
      if (data.isDirectory) {
        return { type: 'directory' };
      } else {
        return { type: 'file' };
      }
    } catch (error) {
      console.error(`Error getting path stats:`, error);
      return null;
    }
  };

  // Check if a folder has content (or is likely to have content)
  const hasFolderContent = (dirPath: string): boolean => {
    // Always assume directories have content to show chevrons
    return true;
  };

  // Auto-expand important folders on initial load
  useEffect(() => {
    if (!templateId || !organizedFileTree || expandedDirs.size > 0) return;
    
    const importantFolders = ['PSAppDeployToolkit', 'Files', 'SupportFiles'];
    const newExpandedDirs = new Set<string>();
    
    // Look for important folders and expand them
    organizedFileTree.dirs.forEach(dir => {
      const dirName = dir.split('/').pop() || '';
      if (importantFolders.includes(dirName)) {
        newExpandedDirs.add(dir);
        fetchDirectoryContents(dir);
      }
    });
    
    if (newExpandedDirs.size > 0) {
      setExpandedDirs(newExpandedDirs);
    }
  }, [templateId, organizedFileTree, expandedDirs, fetchDirectoryContents]);

  // Special case for PSAppDeployToolkit.Extensions in auto-expand
  useEffect(() => {
    if (templateId && fileTree.length > 0 && organizedFileTree) {
      // Check specifically for PSAppDeployToolkit.Extensions
      const extensionsFolder = fileTree.find(path => 
        path.endsWith('PSAppDeployToolkit.Extensions') || 
        path.includes('/PSAppDeployToolkit.Extensions') ||
        path.includes('\\PSAppDeployToolkit.Extensions')
      );
      
      if (extensionsFolder && !expandedDirs.has(extensionsFolder)) {
        console.log(`Found PSAppDeployToolkit.Extensions folder: ${extensionsFolder}`);
        
        // Expand this folder and fetch its contents
        setExpandedDirs(prev => new Set([...prev, extensionsFolder]));
        fetchDirectoryContents(extensionsFolder);
      }
    }
  }, [templateId, fileTree, organizedFileTree, expandedDirs]);

  // Transform fileTree to react-complex-tree format
  const treeItems = useMemo(() => {
    const items: Record<string, any> = {};
    
    // Group by directory
    if (fileTree.length === 0) return items;
    
    // Process files into tree structure
    fileTree.forEach((file) => {
      const parts = file.split('/');
      let currentPath = '';
      
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const isLast = i === parts.length - 1;
        const parentPath = currentPath;
        
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        
        if (!items[currentPath]) {
          items[currentPath] = {
            id: currentPath,
            name: part,
            isFolder: !isLast,
            children: [],
            data: {
              path: currentPath
            },
            parentId: parentPath || null
          };
          
          // Add to parent's children
          if (parentPath && items[parentPath]) {
            items[parentPath].children.push(currentPath);
          }
        }
      }
    });
    
    return items;
  }, [fileTree]);

  // Handle file tree item interaction
  const handleTreeItemAction = useCallback((itemId: string) => {
    if (!treeItems[itemId]) return;
    
    const item = treeItems[itemId];
    const path = item.data?.path as string;
    
    if (item.isFolder) {
      // For folders, we want to expand/collapse
      // The tree handles this automatically
    } else {
      // For files, we want to open
      handleFileClick(new MouseEvent('click') as any, path);
    }
  }, [treeItems]);
  
  // Function to render custom items in the tree
  const renderTreeItem = useCallback(({ item, depth, arrow, context }: any) => {
    const isFolder = item.isFolder;
    const isExpanded = context.isExpanded && context.isExpanded(item.index);
    const isSelected = context.isSelected && context.isSelected(item.index);
    const path = item.data?.path as string;
    const name = path.split(/[/\\]/).pop() || path;
    
    return (
      <div 
        className={cn(
          "flex items-center px-2 py-1 rounded group",
          isSelected ? "bg-blue-500/20" : "hover:bg-slate-800/50"
        )}
      >
        {arrow}
        
        <div className="flex-grow flex items-center overflow-hidden">
          {isFolder ? (
            isExpanded ? (
              <Folder className="mr-2 h-4 w-4 text-blue-500 flex-shrink-0" />
            ) : (
              <FolderTree className="mr-2 h-4 w-4 text-yellow-500 flex-shrink-0" />
            )
          ) : (
            getFileIcon(name)
          )}
          <span className="text-sm truncate">{name}</span>
        </div>
      </div>
    );
  }, []);

  // Add refreshFiles function
  const refreshFiles = useCallback(() => {
    if (templateId) {
      fetchTemplateFiles(templateId);
    }
  }, [templateId, fetchTemplateFiles]);

  // When the file tree is loaded, let's fix the rendering directly
  const renderFilesTree = () => {
    if (!organizedFileTree) return null;
    
    // Helper function to recursively render directories
    const renderDirectory = (dirPath: string, level = 0) => {
      const isExpanded = expandedDirs.has(dirPath);
      const contents = directoryContents[dirPath];
      const dirName = dirPath.split('/').pop() || dirPath;
      const isSpecialFolder = dirPath.includes('PSAppDeployToolkit') || dirPath.includes('Files');
      // Always show chevron for directories - removing the content check
      
      return (
        <div
          key={dirPath} 
          className="mb-2"
          onContextMenu={(e) => handleContextMenu(e, dirPath, 'directory')}
          onDragOver={(e) => handleDragOver(e, dirPath)}
          onDragLeave={handleDragLeave}
          onDrop={(e) => handleDrop(e, dirPath)}
        >
          <div
            className={cn(
              "flex cursor-pointer items-center px-3 py-1.5 rounded group",
              selectedFile === dirPath ? "bg-blue-500/20" : (isExpanded ? "bg-slate-800/50" : "hover:bg-slate-800/50"),
              draggedItem?.path === dirPath ? "opacity-50" : "",
              // Make important folders more noticeable
              isSpecialFolder ? "font-medium" : ""
            )}
          >
            {/* Chevron icon for dropdown - always show for directories */}
            <div 
              className="w-5 h-5 flex items-center justify-center flex-shrink-0 cursor-pointer relative z-10 hover:bg-slate-700 rounded"
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFolder(dirPath, e);
              }}
            >
              <ChevronDown 
                className={cn(
                  "h-5 w-5 text-blue-400 hover:text-blue-300 transition-transform duration-150", 
                  isExpanded ? "" : "-rotate-90"
                )} 
              />
            </div>
            
            {/* Folder name and icon */}
            <div 
              className="flex items-center flex-grow cursor-pointer"
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFolder(dirPath, e);
              }}
              draggable
              onDragStart={(e) => handleDragStart(e, dirPath, 'directory')}
            >
              {/* Folder icon based on type */}
              {isExpanded ? (
                <Folder className="mr-2 h-4 w-4 text-blue-500 flex-shrink-0" />
              ) : dirPath.includes('PSAppDeployToolkit') ? (
                <FolderTree className="mr-2 h-4 w-4 text-yellow-500 flex-shrink-0" />
              ) : (
                <Folder className="mr-2 h-4 w-4 text-yellow-400 flex-shrink-0" />
              )}
              
              <span className="text-sm truncate">{dirName}</span>
            </div>
          </div>
          
          {/* Expanded directory contents */}
          {isExpanded && (
            <div className="ml-5 mt-1 border-l border-slate-700 pl-2">
              {/* If we haven't loaded contents yet */}
              {!contents && (
                <div className="flex items-center py-1 px-2">
                  <RefreshCw className="h-3 w-3 animate-spin text-muted-foreground mr-2" />
                  <span className="text-xs text-muted-foreground">Loading...</span>
                </div>
              )}
              
              {/* If directory is empty */}
              {contents?.length === 0 && (
                <div className="py-1 px-2">
                  <span className="text-xs text-muted-foreground">Empty folder</span>
                </div>
              )}
              
              {/* Directories first, then files */}
              {contents && contents.length > 0 && (
                <>
                  {/* Directories first */}
                  {contents
                    .filter(item => item.type === 'directory')
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .map((item) => renderDirectory(item.path, level + 1))}
                  
                  {/* Then files */}
                  {contents
                    .filter(item => item.type === 'file')
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .map((item) => (
                      <div
                        key={item.path}
                        className={cn(
                          "flex cursor-pointer items-center px-2 py-1 rounded mb-1 group",
                          selectedFile === item.path ? "bg-blue-500 text-white" : "hover:bg-slate-800",
                          draggedItem?.path === item.path ? "opacity-50" : ""
                        )}
                        onContextMenu={(e) => handleContextMenu(e, item.path, 'file')}
                      >
                        {/* Empty space for chevron alignment */}
                        <div className="w-5 h-5 flex-shrink-0"></div>
                        
                        {/* File content */}
                        <div 
                          className="flex items-center flex-grow cursor-pointer"
                          onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handleFileClick(e, item.path);
                          }}
                          draggable
                          onDragStart={(e) => handleDragStart(e, item.path, 'file')}
                        >
                          {getFileIcon(item.name)}
                          <span className="text-sm truncate">{item.name}</span>
                        </div>
                      </div>
                    ))}
                </>
              )}
            </div>
          )}
        </div>
      );
    };

    return (
      <div className="space-y-1">
        {/* Root files */}
        {!searchQuery 
          ? organizedFileTree.rootFiles.map((filePath) => (
              <div
                key={filePath}
                className={cn(
                  "flex cursor-pointer items-center px-2 py-1 rounded group",
                  filePath === selectedFile
                    ? "bg-blue-500 text-white"
                    : "hover:bg-slate-800",
                  draggedItem?.path === filePath ? "opacity-50" : ""
                )}
                onContextMenu={(e) => handleContextMenu(e, filePath, 'file')}
              >
                {/* Empty space for chevron alignment */}
                <div className="w-5 h-5 flex-shrink-0"></div>
                
                {/* File content */}
                <div 
                  className="flex items-center flex-grow cursor-pointer"
                  onClick={(e) => handleFileClick(e, filePath)}
                  draggable
                  onDragStart={(e) => handleDragStart(e, filePath, 'file')}
                >
                  {getFileIcon(filePath)}
                  <span className="text-sm truncate">{getFileName(filePath)}</span>
                </div>
              </div>
            ))
          : null
        }
        
        {/* Search Results */}
        {searchQuery 
          ? filteredFiles.map((filePath) => (
              <div
                key={filePath}
                className={cn(
                  "flex cursor-pointer items-center px-2 py-1 rounded group",
                  filePath === selectedFile
                    ? "bg-blue-500 text-white"
                    : "hover:bg-slate-800",
                  draggedItem?.path === filePath ? "opacity-50" : ""
                )}
                onContextMenu={(e) => handleContextMenu(e, filePath, 'file')}
              >
                {/* Empty space for chevron alignment */}
                <div className="w-5 h-5 flex-shrink-0"></div>
                
                {/* File content */}
                <div 
                  className="flex items-center flex-grow cursor-pointer"
                  onClick={(e) => handleFileClick(e, filePath)}
                  draggable
                  onDragStart={(e) => handleDragStart(e, filePath, 'file')}
                >
                  {getFileIcon(filePath)}
                  <span className="text-sm truncate">
                    {filePath.includes('/') || filePath.includes('\\') 
                      ? formatFilePath(filePath) 
                      : getFileName(filePath)}
                  </span>
                </div>
              </div>
            ))
          : organizedFileTree.dirs.map((dir) => renderDirectory(dir))
        }
      </div>
    );
  };

  if (error) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="bg-red-500/10 text-red-400 border border-red-500/20 rounded-lg p-4">
          {error}
        </div>
      </div>
    );
  }

  return (
    <div style={{ height, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
      <div className="bg-background rounded-t-md border-b flex items-center justify-between p-2">
        <div className="flex items-center">
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={handleSave}
            className="rounded-md px-3 py-1 bg-[#252525] hover:bg-[#2a2a2a] text-[#cccccc]"
            disabled={!isEditorReady || isSaving}
          >
            {isSaving ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-[#4285F4] mr-2"></div>
                Saving...
              </>
            ) : (
              <>
                <Save className="h-4 w-4 mr-2" />
                Save
              </>
            )}
          </Button>
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={handleRun}
            className="rounded-md px-3 py-1 bg-[#252525] hover:bg-[#2a2a2a] text-[#cccccc]"
            disabled={!isEditorReady}
          >
            <Play className="h-4 w-4 mr-2" />
            Run
          </Button>
          
          {saveSuccess !== null && saveMessage && (
            <div className={`ml-4 text-sm ${saveSuccess ? 'text-green-400' : 'text-red-400'}`}>
              {saveMessage}
            </div>
          )}
          
          {selectedFile && !saveMessage && (
            <div className="ml-4 text-sm text-[#cccccc] flex-1 flex items-center">
              {isFileLoading ? (
                <div className="flex items-center">
                  <div className="animate-spin rounded-full h-3 w-3 border-b-2 border-[#4285F4] mr-2"></div>
                  <span>{fileStatus}</span>
                </div>
              ) : fileError ? (
                <div className="flex items-center text-red-400">
                  <AlertTriangle className="h-3 w-3 mr-2" />
                  <span>{fileError}</span>
                </div>
              ) : isBinaryFile ? (
                <div className="flex items-center text-yellow-400">
                  <AlertTriangle className="h-3 w-3 mr-2" />
                  <span>Binary file cannot be displayed in editor</span>
                </div>
              ) : (
                <div className="flex items-center">
                  <span className="opacity-70">{selectedFile}</span>
                  {isDirty && <span className="ml-2 text-yellow-400">*</span>}
                </div>
              )}
            </div>
          )}
          
          <Button
            size="sm"
            variant="ghost"
            onClick={toggleSearch}
            className="text-xs mr-2 ml-2"
            title="Search files (Ctrl+F)"
          >
            <Search className="h-4 w-4 mr-1" />
            {showSearch ? "Hide Search" : "Search"}
          </Button>
          
          {/* Add theme switcher */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                size="sm"
                variant="ghost"
                className="text-xs mr-2"
                title="Editor Settings"
              >
                <Settings className="h-4 w-4 mr-1" />
                Settings
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="start" className="w-56">
              <DropdownMenuLabel>Theme</DropdownMenuLabel>
              <DropdownMenuSeparator />
              {themes.map(t => (
                <DropdownMenuItem
                  key={t.value}
                  onClick={() => handleThemeChange(t.value)}
                  className={cn(
                    "cursor-pointer",
                    editorTheme === t.value && "bg-accent text-accent-foreground"
                  )}
                >
                  {t.name === 'Dark' && <Moon className="h-4 w-4 mr-2" />}
                  {t.name === 'Light' && <Sun className="h-4 w-4 mr-2" />}
                  {t.name === 'High Contrast' && <AlertTriangle className="h-4 w-4 mr-2" />}
                  {t.name}
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
        
        {showSearch && (
          <div className="bg-background border-b p-2 flex gap-2 items-center">
            <Input
              type="text"
              placeholder="Search files by name..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="h-8 text-sm flex-1"
            />
            {searchQuery && (
              <Button 
                size="icon" 
                variant="ghost" 
                onClick={clearSearch} 
                className="h-8 w-8 p-0"
              >
                <X className="h-4 w-4" />
              </Button>
            )}
            <Button 
              size="sm" 
              variant="secondary" 
              onClick={searchInFiles}
              disabled={isSearching || !searchQuery.trim()}
              className="h-8"
            >
              {isSearching ? (
                <RefreshCw className="h-4 w-4 animate-spin" />
              ) : (
                <Search className="h-4 w-4 mr-1" />
              )}
              Search
            </Button>
          </div>
        )}
      </div>
      
      <div className="flex flex-1 overflow-hidden">
        <div className="w-60 bg-[#202020] overflow-y-auto border-r border-gray-800">
          <div className="p-3">
            {showSearch && (
              <div className="mb-3 relative">
                <Input
                  type="text"
                  placeholder="Search files..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="bg-[#252525] border-none text-sm"
                />
                <button
                  onClick={() => setShowSearch(false)}
                  className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white"
                >
                  <X className="h-4 w-4" />
                </button>
              </div>
            )}
            
            <div className="flex mb-3 justify-between items-center">
              <h3 className="text-xs font-medium text-[#cccccc] uppercase tracking-wider">Files</h3>
              <div className="flex space-x-1">
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => setShowNewFileDialog(true)}
                  className="h-6 w-6 p-0"
                >
                  <FileText className="h-3 w-3" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => setShowNewFolderDialog(true)}
                  className="h-6 w-6 p-0"
                >
                  <Folder className="h-3 w-3" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={() => setShowSearch(!showSearch)}
                  className="h-6 w-6 p-0"
                >
                  <Search className="h-3 w-3" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  onClick={refreshFiles}
                  className="h-6 w-6 p-0"
                >
                  <RefreshCw className="h-3 w-3" />
                </Button>
              </div>
            </div>
            
            {/* Debug UI to show raw file data */}
            {fileTree.length === 0 && !isFileLoading && (
              <div className="text-xs text-amber-400 p-2 mb-2 bg-amber-500/10 rounded">
                No files found. Click "Create PowerShell File" above.
              </div>
            )}
            
            {/* Use filtered files for display when searching */}
            {isFileLoading ? (
              <div className="flex justify-center items-center h-10">
                <RefreshCw className="h-4 w-4 animate-spin text-muted-foreground" />
              </div>
            ) : fileError ? (
              <div className="text-xs text-red-400 p-2 bg-red-500/10 rounded">
                {fileError}
              </div>
            ) : (
              <>
                {searchQuery && filteredFiles.length > 0 ? (
                  <div className="mb-4">
                    <div className="text-xs font-medium text-muted-foreground mb-1">
                      Search Results ({filteredFiles.length})
                    </div>
                    <div className="space-y-1">
                      {filteredFiles.map((file) => (
                        <div
                          key={file}
                          onContextMenu={(e) => handleContextMenu(e, file, 'file')}
                          className={cn(
                            "text-xs py-1 px-2 rounded cursor-pointer flex items-center",
                            file === selectedFile
                              ? "bg-blue-500 text-white"
                              : "hover:bg-slate-800",
                            draggedItem?.path === file ? "opacity-50" : ""
                          )}
                        >
                          <div 
                            className="flex-grow flex items-center"
                            onClick={(e) => handleFileClick(e, file)}
                            draggable
                            onDragStart={(e) => handleDragStart(e, file, 'file')}
                          >
                            {getFileIcon(file)}
                            <span className="truncate">{formatFilePath(file)}</span>
                          </div>
                          
                          {/* Dropdown menu for search result files */}
                          <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                              <Button 
                                variant="ghost" 
                                size="sm" 
                                className="h-6 w-6 p-0 ml-1 opacity-70 hover:opacity-100"
                                onClick={(e) => e.stopPropagation()}
                              >
                                <MoreVertical className="h-3 w-3" />
                              </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end" className="w-48">
                              <DropdownMenuLabel>File Actions</DropdownMenuLabel>
                              <DropdownMenuSeparator />
                              <DropdownMenuItem onClick={() => handleRename(file, 'file')}>
                                Rename
                              </DropdownMenuItem>
                              <DropdownMenuItem 
                                variant="destructive"
                                onClick={() => handleDelete(file, 'file')}
                              >
                                Delete
                              </DropdownMenuItem>
                            </DropdownMenuContent>
                          </DropdownMenu>
                        </div>
                      ))}
                    </div>
                  </div>
                ) : !searchQuery && organizedFileTree ? (
                  /* Use our file tree rendering function */
                  renderFilesTree()
                ) : null}
              </>
            )}
          </div>
        </div>
        
        <div className={cn("flex-1 relative", loading ? "bg-[#1e1e1e]" : "")}>
          {loading && (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="flex flex-col items-center">
                <div 
                  className="animate-spin rounded-full h-10 w-10 border-b-2 border-[#4285F4]"
                ></div>
                <p className="mt-4 text-sm text-[#cccccc]">
                  Loading editor...
                </p>
              </div>
            </div>
          )}
          
          {isBinaryFile && selectedFile ? (
            <div className="absolute inset-0 flex items-center justify-center bg-[#1e1e1e]">
              <div className="bg-[#252526] p-8 rounded-md text-center">
                <AlertTriangle className="h-12 w-12 text-yellow-400 mx-auto mb-4" />
                <h3 className="text-lg text-[#cccccc] mb-2">Binary File</h3>
                <p className="text-sm text-[#cccccc] mb-4">
                  This file cannot be displayed in the editor.
                </p>
                <p className="text-xs text-[#8a8a8a] max-w-md">
                  File: {selectedFile}
                </p>
              </div>
            </div>
          ) : (
            <div
              ref={containerRef}
              className="w-full h-full"
              style={{ visibility: loading ? 'hidden' : 'visible' }}
            >
              {/* 
                Instead of using the Monaco-Editor/React component, we'll manually
                initialize Monaco editor for better control. See the useEffect hook
                that loads Monaco above.
              */}
            </div>
          )}
        </div>
      </div>

      {/* New File Dialog */}
      {showNewFileDialog && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-background p-4 rounded-md shadow-lg w-80">
            <h3 className="text-md font-medium mb-4">Create New File</h3>
            <div className="mb-4">
              <label className="block text-sm text-muted-foreground mb-2">
                File Name:
              </label>
              <Input
                type="text"
                placeholder="example.ps1"
                value={newItemName}
                onChange={(e) => setNewItemName(e.target.value)}
                className="w-full"
                autoFocus
              />
            </div>
            <div className="flex justify-end space-x-2">
              <Button variant="outline" onClick={() => setShowNewFileDialog(false)}>
                Cancel
              </Button>
              <Button onClick={submitNewFile} disabled={!newItemName.trim()}>
                Create
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* New Folder Dialog */}
      {showNewFolderDialog && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-background p-4 rounded-md shadow-lg w-80">
            <h3 className="text-md font-medium mb-4">Create New Folder</h3>
            <div className="mb-4">
              <label className="block text-sm text-muted-foreground mb-2">
                Folder Name:
              </label>
              <Input
                type="text"
                placeholder="New Folder"
                value={newItemName}
                onChange={(e) => setNewItemName(e.target.value)}
                className="w-full"
                autoFocus
              />
            </div>
            <div className="flex justify-end space-x-2">
              <Button variant="outline" onClick={() => setShowNewFolderDialog(false)}>
                Cancel
              </Button>
              <Button onClick={submitNewFolder} disabled={!newItemName.trim()}>
                Create
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Rename Dialog */}
      {showRenameDialog && renameTarget && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-background p-4 rounded-md shadow-lg w-80">
            <h3 className="text-md font-medium mb-4">
              Rename {renameTarget.type === 'directory' ? 'Folder' : 'File'}
            </h3>
            <div className="mb-4">
              <label className="block text-sm text-muted-foreground mb-2">
                New Name:
              </label>
              <Input
                type="text"
                value={renameValue}
                onChange={(e) => setRenameValue(e.target.value)}
                className="w-full"
                autoFocus
              />
            </div>
            <div className="flex justify-end space-x-2">
              <Button variant="outline" onClick={() => setShowRenameDialog(false)}>
                Cancel
              </Button>
              <Button onClick={submitRename} disabled={!renameValue.trim()}>
                Rename
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* Context Menu */}
      {contextMenuPos && contextMenuTarget && (
        <div
          className="fixed z-50 bg-background border shadow-md rounded-md py-1 w-48"
          style={{ 
            top: `${contextMenuPos.y}px`, 
            left: `${contextMenuPos.x}px`,
            maxWidth: '12rem' 
          }}
        >
          <div className="px-2 py-1 text-xs text-muted-foreground truncate border-b">
            {contextMenuTarget.path.split('/').pop()}
          </div>
          <div 
            className="px-3 py-1.5 text-sm cursor-pointer hover:bg-slate-700"
            onClick={() => {
              if (contextMenuTarget.type === 'directory') {
                handleCreateFile(contextMenuTarget.path);
              } else {
                const dirPath = contextMenuTarget.path.split('/').slice(0, -1).join('/');
                handleCreateFile(dirPath);
              }
              closeContextMenu();
            }}
          >
            New File
          </div>
          <div 
            className="px-3 py-1.5 text-sm cursor-pointer hover:bg-slate-700"
            onClick={() => {
              if (contextMenuTarget.type === 'directory') {
                handleCreateFolder(contextMenuTarget.path);
              } else {
                const dirPath = contextMenuTarget.path.split('/').slice(0, -1).join('/');
                handleCreateFolder(dirPath);
              }
              closeContextMenu();
            }}
          >
            New Folder
          </div>
          <div 
            className="px-3 py-1.5 text-sm cursor-pointer hover:bg-slate-700"
            onClick={() => handleRename(contextMenuTarget.path, contextMenuTarget.type)}
          >
            Rename
          </div>
          <div className="border-t"></div>
          <div 
            className="px-3 py-1.5 text-sm cursor-pointer hover:bg-red-800 text-red-400 hover:text-white"
            onClick={() => handleDelete(contextMenuTarget.path, contextMenuTarget.type)}
          >
            Delete
          </div>
        </div>
      )}

      {/* Click away listener for context menu */}
      {contextMenuPos && (
        <div
          className="fixed inset-0 z-40"
          onClick={closeContextMenu}
        />
      )}

      {/* Keyboard shortcuts dialog */}
      {showKeyboardShortcuts && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-background p-6 rounded-md shadow-lg w-96">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-lg font-semibold">Keyboard Shortcuts</h3>
              <Button 
                variant="ghost" 
                size="icon" 
                onClick={() => setShowKeyboardShortcuts(false)}
                className="h-8 w-8"
              >
                <X className="h-5 w-5" />
              </Button>
            </div>
            
            <div className="space-y-3">
              <div className="grid grid-cols-2 gap-2">
                <div className="text-sm font-medium">New File</div>
                <div className="text-sm font-mono bg-slate-800 px-2 py-1 rounded">Ctrl + Alt + N</div>
                
                <div className="text-sm font-medium">New Folder</div>
                <div className="text-sm font-mono bg-slate-800 px-2 py-1 rounded">Ctrl + Alt + F</div>
                
                <div className="text-sm font-medium">Rename Selected</div>
                <div className="text-sm font-mono bg-slate-800 px-2 py-1 rounded">F2</div>
                
                <div className="text-sm font-medium">Delete Selected</div>
                <div className="text-sm font-mono bg-slate-800 px-2 py-1 rounded">Delete</div>
                
                <div className="text-sm font-medium">Save File</div>
                <div className="text-sm font-mono bg-slate-800 px-2 py-1 rounded">Ctrl + S</div>
                
                <div className="text-sm font-medium">Search</div>
                <div className="text-sm font-mono bg-slate-800 px-2 py-1 rounded">Ctrl + F</div>
              </div>
              
              <div className="mt-4 pt-2 border-t border-slate-700 text-xs text-muted-foreground">
                Right-click on files or folders to access the context menu for more options.
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
} 